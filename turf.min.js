/*!
Turf.js - v6.5.0
An open-source module for performing geospatial analysis in JavaScript
https://turfjs.org/
*/
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.turf = {}));
}(this, (function (exports) { 'use strict';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var isObject = function (obj) {
  var type = typeof obj;
  return type === 'function' || type === 'object' && !!obj;
};

var isObject_1 = isObject;

var isArray = Array.isArray;

/**
 * toInteger converts to an integer value.
 * @param {*} value to convert to an integer
 * @returns {integer}
 */
function toInteger(value) {
  if (value === undefined) { return 0; }
  if (value === null) { return 0; }
  if (typeof value === 'number') { return value < 0 ? Math.ceil(value) : Math.floor(value); }
  if (typeof value === 'string') {
    var num = Number(value);
    if (Number.isNaN(num)) { return 0; }
    return toInteger(num);
  }
  if (typeof value === 'boolean') { return value ? 1 : 0; }
  return 0;
}

/**
 * toInt32 converts to an int32 value.
 * @param {*} value to convert to an int32
 * @returns {number}
 */
function toInt32(value) {
  return toInteger(value) % 2147483647;
}

/**
 * Units of measurement factors using a MILES reference.
 *
 * @memberof turf
 * @type {Object}
 */
var factors = {
    centimeters: 1.60934e+5,
    feet: 5280,
    inches: 63360,
    kilometers: 1.60934,
    meters: 1609.34,
    miles: 1,
    nauticalmiles: 0.868976,
    radians: 0.0174533,
    degrees: 111.139
};

/**
 * Area of measurement factors based on 1 square kilometer.
 *
 * @memberof turf
 * @type {Object}
 */
var areaFactors = {
    kilometers: 1,
    miles: 0.386102,
    meters: 1000000,
    centimeters: 10000000000,
    feet: 10763910.417,
    inches: 155000310000,
    yards: 1195990.0463,
    acres: 247.105,
    hectares: 100
};

/**
 * Validates that a value is not a number.
 *
 * @private
 * @param {*} num Number to validate.
 * @returns {boolean} True if the value is not a number, false if number.
 */
function isNaN(num) {
    if (num === null) { return true; }
    if (num === undefined) { return true; }
    if (typeof num === 'string') { return true; }
    return Number.isNaN(num);
}

/**
 * Earth Radius used with the Harvesine formula and units conversion.
 *
 * @memberof turf
 * @type {Object}
 */
var earthRadius = {
    meters: 6371008.8,
    miles: 3958.8,
    kilometers: 6371.0088,
    radians: 6371008.8,
    degrees: 6371008.8
};

/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, kilometers, degrees, radians, meters, inches, yards, feet, nauticalmiles.
 *
 * @memberof turf
 * @param {number} distance in radians
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, feet, nauticalmiles
 * @returns {number} converted distance
 */
function radiansToLength(distance, units) {
    if (units === void 0) { units = 'kilometers'; }

    var factor = earthRadius[units];
    if (factor === undefined) { throw new Error('invalid units'); }

    return distance * factor;
}

/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians.
 * Valid units: miles, kilometers, degrees, radians, meters, inches, yards, feet, nauticalmiles.
 *
 * @memberof turf
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, feet, nauticalmiles
 * @returns {number} Radians
 */
function lengthToRadians(distance, units) {
    if (units === void 0) { units = 'kilometers'; }

    var factor = earthRadius[units];
    if (factor === undefined) { throw new Error('invalid units'); }

    return distance / factor;
}

/**
 * Converts an angle in degrees to radians
 *
 * @memberof turf
 * @param {number} degrees angle in degrees
 * @returns {number} angle in radians
 */
function degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * Converts an angle in radians to degrees
 *
 * @memberof turf
 * @param {number} radians angle in radians
 * @returns {number} angle in degrees
 */
function radiansToDegrees(radians) {
    return radians * 180 / Math.PI;
}

/**
 * Converts a length to the requested unit.
 *
 * @param {number} length to be converted.
 * @param {string} originalUnit of the length.
 * @param {string} finalUnit of the length.
 * @returns {number} converted length.
 */
function convertLength(length, originalUnit, finalUnit) {
    if (length === undefined || length === null) { throw new Error('length is required'); }
    if (!(typeof length === 'number' || typeof length === 'string') || isNaN(Number(length))) { throw new Error('length must be a number'); }

    if (!originalUnit) { throw new Error('originalUnit is required'); }
    if (typeof originalUnit !== 'string') { throw new Error('originalUnit must be a string'); }
    if (!factors[originalUnit]) { throw new Error('invalid originalUnit'); }

    if (!finalUnit) { throw new Error('finalUnit is required'); }
    if (typeof finalUnit !== 'string') { throw new Error('finalUnit must be a string'); }
    if (!factors[finalUnit]) { throw new Error('invalid finalUnit'); }

    var startFactor = factors[originalUnit];
    var endFactor = factors[finalUnit];

    return length / startFactor * endFactor;
}

/**
 * Converts a area to the requested unit.
 *
 * @param {number} area to be converted.
 * @param {string} originalUnit of the area.
 * @param {string} finalUnit of the area.
 * @returns {number} converted area.
 */
function convertArea(area, originalUnit, finalUnit) {
    if (area === undefined || area === null) { throw new Error('area is required'); }
    if (!(typeof area === 'number' || typeof area === 'string') || isNaN(Number(area))) { throw new Error('area must be a number'); }

    if (!originalUnit) { throw new Error('originalUnit is required'); }
    if (typeof originalUnit !== 'string') { throw new Error('originalUnit must be a string'); }
    if (!areaFactors[originalUnit]) { throw new Error('invalid originalUnit'); }

    if (!finalUnit) { throw new Error('finalUnit is required'); }
    if (typeof finalUnit !== 'string') { throw new Error('finalUnit must be a string'); }
    if (!areaFactors[finalUnit]) { throw new Error('invalid finalUnit'); }

    var startFactor = areaFactors[originalUnit];
    var endFactor = areaFactors[finalUnit];

    return area / startFactor * endFactor;
}

/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('123')
 * //=false
 * turf.isNumber(null)
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num) && typeof num === 'number';
}

/**
 * isNull
 *
 * @param {*} value to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNull(null)
 * //=true
 * turf.isNull(NaN)
 * //=false
 * turf.isNull([1, 2])
 * //=false
 */
function isNull(value) {
  return value === null;
}

/**
 * isBoolean
 *
 * @param {*} value to validate
 * @returns {boolean} true/false
 * @example
 * turf.isBoolean(true)
 * //=true
 * turf.isBoolean('true')
 * //=false
 * turf.isBoolean(1)
 * //=false
 */
function isBoolean(value) {
  return value === true || value === false;
}

/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws {Error} if BBox is not valid
 * @example
 * turf.validateBBox([-180, -90, 180, 90])
 * //=OK
 * turf.validateBBox([-180, -100, 180, 90])
 * //=Error
 */
function validateBBox(bbox) {
    if (!bbox) { throw new Error('bbox is required'); }
    if (!Array.isArray(bbox)) { throw new Error('bbox must be an Array'); }
    if (bbox.length !== 4 && bbox.length !== 6) { throw new Error('bbox must be an Array of 4 or 6 numbers'); }

    bbox.forEach(function (num) {
        if (!isNumber(num)) { throw new Error('bbox must only contain numbers'); }
    });

    if (bbox.length === 4) {
        if (bbox[0] > bbox[2]) { throw new Error('bbox[0] must be <= bbox[2]'); }
        if (bbox[1] > bbox[3]) { throw new Error('bbox[1] must be <= bbox[3]'); }
        if (bbox[0] < -180) { throw new Error('bbox[0] must be >= -180'); }
        if (bbox[1] < -90) { throw new Error('bbox[1] must be >= -90'); }
        if (bbox[2] > 180) { throw new Error('bbox[2] must be <= 180'); }
        if (bbox[3] > 90) { throw new Error('bbox[3] must be <= 90'); }
    } else {
        if (bbox[0] > bbox[3]) { throw new Error('bbox[0] must be <= bbox[3]'); }
        if (bbox[1] > bbox[4]) { throw new Error('bbox[1] must be <= bbox[4]'); }
        if (bbox[2] > bbox[5]) { throw new Error('bbox[2] must be <= bbox[5]'); }
        if (bbox[0] < -180) { throw new Error('bbox[0] must be >= -180'); }
        if (bbox[1] < -90) { throw new Error('bbox[1] must be >= -90'); }
        if (bbox[3] > 180) { throw new Error('bbox[3] must be <= 180'); }
        if (bbox[4] > 90) { throw new Error('bbox[4] must be <= 90'); }
    }
}

/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws {Error} if Id is not valid
 * @example
 * turf.validateId(123)
 * //=OK
 * turf.validateId('123')
 * //=OK
 * turf.validateId(null)
 * //=Error
 */
function validateId(id) {
    if (id === undefined || id === null) { throw new Error('id is required'); }
    if (typeof id === 'number') { return; }
    if (typeof id === 'string') { return; }
    throw new Error('id must be a number or a string');
}

/**
 * Validation of FeatureCollection.
 *
 * @private
 * @param {FeatureCollection} featureCollection FeatureCollection
 * @returns {void}
 * @throws {Error} if FeatureCollection is not valid
 * @example
 * var featureCollection = {
 *   "type": "FeatureCollection",
 *   "features": []
 * };
 * turf.validateFeatureCollection(featureCollection);
 * //=OK
 */
function validateFeatureCollection(featureCollection) {
    if (!featureCollection) { throw new Error('featureCollection is required'); }
    if (typeof featureCollection !== 'object') { throw new Error('featureCollection must be an Object'); }
    if (featureCollection.type !== 'FeatureCollection') { throw new Error('featureCollection.type must be FeatureCollection'); }
    if (!featureCollection.features) { throw new Error('featureCollection.features is required'); }
    if (!Array.isArray(featureCollection.features)) { throw new Error('featureCollection.features must be an Array'); }
}

/**
 * Validation of Feature.
 *
 * @private
 * @param {Feature<any>} feature GeoJSON Feature
 * @returns {void}
 * @throws {Error} if Feature is not valid
 * @example
 * var feature = {
 *   "type": "Feature",
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 50]
 *   },
 *   "properties": {}
 * };
 * turf.validateFeature(feature);
 * //=OK
 */
function validateFeature(feature) {
    if (!feature) { throw new Error('feature is required'); }
    if (typeof feature !== 'object') { throw new Error('feature must be an Object'); }
    if (feature.type !== 'Feature') { throw new Error('feature.type must be Feature'); }
    if (feature.id !== undefined) { validateId(feature.id); }
}

/**
 * Validation of Geometry.
 *
 * @private
 * @param {Geometry<any>} geometry GeoJSON Geometry
 * @returns {void}
 * @throws {Error} if Geometry is not valid
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 * turf.validateGeometry(geometry);
 * //=OK
 */
function validateGeometry(geometry) {
    if (!geometry) { throw new Error('geometry is required'); }
    if (typeof geometry !== 'object') { throw new Error('geometry must be an Object'); }
    if (!geometry.type) { throw new Error('geometry.type is required'); }
}

/**
 * Get Geometry from Feature or Geometry Object
 *
 * @private
 * @param {Feature<any>|Geometry<any>} geojson GeoJSON Feature or Geometry
 * @returns {Geometry<any>} GeoJSON Geometry
 * @throws {Error} if geojson is not a Feature or Geometry
 * @example
 * var point = {
 *   "type": "Feature",
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 50]
 *   },
 *   "properties": {}
 * };
 * turf.getGeom(point);
 * //={
 * //  "type": "Point",
 * //  "coordinates": [110, 50]
 * //}
 */
function getGeom(geojson) {
    if (geojson.type === 'Feature') { return geojson.geometry; }
    return geojson;
}

/**
 * Get Geometry Type from Feature or Geometry Object
 *
 * @private
 * @param {Feature<any>|Geometry<any>} geojson GeoJSON Feature or Geometry
 * @returns {string} GeoJSON Geometry Type
 * @throws {Error} if geojson is not a Feature or Geometry
 * @example
 * var point = {
 *   "type": "Feature",
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 50]
 *   },
 *   "properties": {}
 * };
 * turf.getType(point);
 * //="Point"
 */
function getType(geojson) {
    if (geojson.type === 'Feature') { return geojson.geometry.type; }
    return geojson.type;
}

/**
 * Get Feature Id
 *
 * @private
 * @param {Feature<any>} feature GeoJSON Feature
 * @returns {string|number} Id
 * @throws {Error} if feature does not have an id
 * @example
 * var feature = {
 *   "type": "Feature",
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 50]
 *   },
 *   "properties": {},
 *   "id": 1
 * };
 * turf.getId(feature);
 * //=1
 */
function getId(feature) {
    if (feature.id === undefined || feature.id === null) { throw new Error('feature must have an id'); }
    return feature.id;
}

/**
 * Get BBox from Feature or Geometry Object
 *
 * @private
 * @param {Feature<any>|Geometry<any>} geojson GeoJSON Feature or Geometry
 * @returns {Array<number>} BBox of the Feature or Geometry
 * @throws {Error} if geojson is not a Feature or Geometry
 * @example
 * var point = {
 *   "type": "Feature",
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 50]
 *   },
 *   "properties": {}
 * };
 * turf.getBBox(point);
 * //=null
 */
function getBBox(geojson) {
    if (geojson.bbox) { return geojson.bbox; }
    return null;
}

/**
 * Get Properties from Feature or Geometry Object
 *
 * @private
 * @param {Feature<any>|Geometry<any>} geojson GeoJSON Feature or Geometry
 * @returns {Object} Properties of the Feature or Geometry
 * @throws {Error} if geojson is not a Feature or Geometry
 * @example
 * var point = {
 *   "type": "Feature",
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 50]
 *   },
 *   "properties": {
 *     "name": "foo"
 *   }
 * };
 * turf.getProps(point);
 * //={"name": "foo"}
 */
function getProps(geojson) {
    if (geojson.type === 'Feature') { return geojson.properties; }
    return {};
}

/**
 * Set Properties to Feature or Geometry Object
 *
 * @private
 * @param {Feature<any>|Geometry<any>} geojson GeoJSON Feature or Geometry
 * @param {Object} properties Properties to set
 * @returns {Feature<any>|Geometry<any>} GeoJSON Feature or Geometry
 * @throws {Error} if geojson is not a Feature or Geometry
 * @example
 * var point = {
 *   "type": "Feature",
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 50]
 *   },
 *   "properties": {
 *     "name": "foo"
 *   }
 * };
 * turf.setProps(point, {name: 'bar'});
 * //={
 * //  "type": "Feature",
 * //  "geometry": {
 * //    "type": "Point",
 * //    "coordinates": [110, 50]
 * //  },
 * //  "properties": {
 * //    "name": "bar"
 * //  }
 * //}
 */
function setProps(geojson, properties) {
    if (geojson.type === 'Feature') {
        geojson.properties = properties;
        return geojson;
    }
    return properties;
}

/**
 * Get Coordinates from Feature or Geometry Object
 *
 * @private
 * @param {Feature<any>|Geometry<any>} geojson GeoJSON Feature or Geometry
 * @returns {Array<number>} Coordinates of the Feature or Geometry
 * @throws {Error} if geojson is not a Feature or Geometry
 * @throws {Error} if geometry is not a Point
 * @example
 * var point = {
 *   "type": "Feature",
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 50]
 *   },
 *   "properties": {}
 * };
 * turf.getCoords(point);
 * //=[110, 50]
 */
function getCoords(geojson) {
    if (geojson.type === 'Feature') { return geojson.geometry.coordinates; }
    return geojson.coordinates;
}

/**
 * Set Coordinates to Feature or Geometry Object
 *
 * @private
 * @param {Feature<any>|Geometry<any>} geojson GeoJSON Feature or Geometry
 * @param {Array<number>} coordinates Coordinates to set
 * @returns {Feature<any>|Geometry<any>} GeoJSON Feature or Geometry
 * @throws {Error} if geojson is not a Feature or Geometry
 * @throws {Error} if geometry is not a Point
 * @example
 * var point = {
 *   "type": "Feature",
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 50]
 *   },
 *   "properties": {}
 * };
 * turf.setCoords(point, [120, 60]);
 * //={
 * //  "type": "Feature",
 * //  "geometry": {
 * //    "type": "Point",
 * //    "coordinates": [120, 60]
 * //  },
 * //  "properties": {}
 * //}
 */
function setCoords(geojson, coordinates) {
    if (geojson.type === 'Feature') {
        geojson.geometry.coordinates = coordinates;
        return geojson;
    }
    geojson.coordinates = coordinates;
    return geojson;
}

/**
 * Validates that a coordinate is a number array
 *
 * @private
 * @param {Array<number>} coord Coordinate to validate
 * @returns {void}
 * @throws {Error} if coordinate is not valid
 * @example
 * turf.validateCoord([-180, 90])
 * //=OK
 * turf.validateCoord([-190, 90])
 * //=Error
 * turf.validateCoord(['foo', 90])
 * //=Error
 * turf.validateCoord([1, 2, 3])
 * //=Error
 */
function validateCoord(coord) {
    if (!coord) { throw new Error('coord is required'); }
    if (!Array.isArray(coord)) { throw new Error('coord must be an array'); }
    if (coord.length < 2) { throw new Error('coord must be at least 2 numbers'); }
    if (coord.length > 3) { throw new Error('coord must be no more than 3 numbers'); }
    coord.forEach(function (num) {
        if (!isNumber(num)) { throw new Error('coord must only contain numbers'); }
    });
    if (coord[0] < -180) { throw new Error('coord[0] must be >= -180'); }
    if (coord[0] > 180) { throw new Error('coord[0] must be <= 180'); }
    if (coord[1] < -90) { throw new Error('coord[1] must be >= -90'); }
    if (coord[1] > 90) { throw new Error('coord[1] must be <= 90'); }
    if (coord.length === 3 && coord[2] < -Infinity) { throw new Error('coord[2] must be >= -Infinity'); }
    if (coord.length === 3 && coord[2] > Infinity) { throw new Error('coord[2] must be <= Infinity'); }
}

/**
 * Validates that all coordinates in a line string are valid.
 *
 * @private
 * @param {Array<Array<number>>} coords Coordinates to validate
 * @returns {void}
 * @throws {Error} if coordinate is not valid
 * @example
 * turf.validateLineString([[-180, 90], [-120, 80]])
 * //=OK
 * turf.validateLineString([[-190, 90], [-120, 80]])
 * //=Error
 * turf.validateLineString([['foo', 90], [-120, 80]])
 * //=Error
 * turf.validateLineString([[1, 2, 3], [-120, 80]])
 * //=Error
 */
function validateLineString(coords) {
    if (!coords) { throw new Error('coords is required'); }
    if (!Array.isArray(coords)) { throw new Error('coords must be an array'); }
    coords.forEach(function (coord) {
        validateCoord(coord);
    });
}

/**
 * Validates that all coordinates in a polygon are valid.
 *
 * @private
 * @param {Array<Array<Array<number>>>} coords Coordinates to validate
 * @returns {void}
 * @throws {Error} if coordinate is not valid
 * @example
 * turf.validatePolygon([[[-180, 90], [-120, 80], [-150, 40], [-180, 90]]])
 * //=OK
 * turf.validatePolygon([[[-190, 90], [-120, 80], [-150, 40], [-180, 90]]])
 * //=Error
 * turf.validatePolygon([[['foo', 90], [-120, 80], [-150, 40], [-180, 90]]])
 * //=Error
 * turf.validatePolygon([[[1, 2, 3], [-120, 80], [-150, 40], [-180, 9